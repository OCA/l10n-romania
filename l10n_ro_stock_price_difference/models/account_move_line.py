# Copyright (C) 2022 NextERP Romania
# Copyright (C) 2020 Terrabit
# License AGPL-3.0 or later (http://www.gnu.org/licenses/agpl.html).

import logging

from odoo import models, fields
from odoo.tools.float_utils import float_is_zero

_logger = logging.getLogger(__name__)


class AccountMoveLine(models.Model):
    _name = "account.move.line"
    _inherit = ["account.move.line", "l10n.ro.mixin"]


    def _apply_price_difference(self):
        svls, amls = super(AccountMoveLine, self)._apply_price_difference()
        models._logger.error(f"++++++++++++++++{svls, amls}+++++++++++++++++++++++")
        return svls, amls
    
    def _generate_price_difference_vals(self, layers):
        svlObj = self.env['stock.valuation.layer']
        svl_vals_list, aml_vals_list = super(AccountMoveLine, self)._generate_price_difference_vals(layers)
        for svl in svl_vals_list:
            svl_parent = svlObj.browse(svl.get('stock_valuation_layer_id'))
            svl.update({
                'stock_move_id': svl_parent.stock_move_id.id,
                })
            svl_parent.write({
                'account_move_line_id': (svl_parent.account_move_line_id or self).id,
                'account_move_id': (svl_parent.account_move_id or self.move_id).id,
                'l10n_ro_invoice_line_id': (svl_parent.account_move_line_id or self).id,
                'l10n_ro_invoice_id': (svl_parent.account_move_id or self.move_id).id,
                })
        return svl_vals_list, aml_vals_list
    
    def _prepare_pdiff_svl_vals(self, corrected_layer, quantity, unit_cost, pdiff):
        vals = super(AccountMoveLine, self)._prepare_pdiff_svl_vals(corrected_layer, quantity, unit_cost, pdiff)
        vals.update({
            'l10n_ro_account_id': self.account_id.id,
            'account_move_line_id': self.id,
            'account_move_id': self.move_id.id,
            'l10n_ro_invoice_line_id': self.id,
            'l10n_ro_invoice_id': self.move_id.id,
            })
        return vals
    
    def _l10n_ro_get_stock_valuation_layer(self, val_stock_move):
        """filter svl"""
        return val_stock_move.sudo().mapped("stock_valuation_layer_ids").filtered(
                    lambda l: not l.stock_landed_cost_id
                    or l.stock_landed_cost_id.l10n_ro_cost_type == "price_diff"
                )
    
    def l10n_ro_get_stock_valuation_difference(self):
        """Se obtine diferenta dintre evaloarea stocului si valoarea din factura"""
        line = self
        diff, qty_diff = 0.0, 0.0
        # Retrieve stock valuation moves.
        if not line.purchase_line_id:
            return diff, qty_diff
    
        if line.purchase_line_id.product_id.purchase_method != "receive":
            return diff, qty_diff
    
        valuation_stock_moves = self._l10n_ro_get_valuation_stock_moves()
        if not valuation_stock_moves:
            return diff, qty_diff
    
        valuation_total = 0
        valuation_total_qty = 0
        for val_stock_move in valuation_stock_moves:
            # Take normal svl and svl generated by price difference.
            svl = self._l10n_ro_get_stock_valuation_layer(val_stock_move)
            layers_qty = sum(svl.mapped("quantity"))
            layers_values = sum(svl.mapped("value"))
    
            valuation_total += layers_values
            valuation_total_qty += layers_qty
    
        precision = line.product_uom_id.rounding or line.product_id.uom_id.rounding
        if float_is_zero(valuation_total_qty, precision_rounding=precision):
            return diff, qty_diff
    
        lines = self.search(
            [
                ("purchase_line_id", "=", line.purchase_line_id.id),
                ("move_id.state", "!=", "cancel"),
            ]
        )
        inv_qty = 0
        for line in lines:
            line_qty = line.product_uom_id._compute_quantity(
                line.quantity, line.product_id.uom_id
            )
            inv_qty += (-1 if line.move_id.move_type == "in_refund" else 1) * line_qty
    
        if inv_qty * valuation_total_qty:
            accc_balance = sum(lines.mapped("balance")) / inv_qty * valuation_total_qty
        else:
            accc_balance = 0
        diff = abs(accc_balance) - valuation_total
        currency = line.currency_id or self.env.company.currency_id
        diff = currency.round(diff)
        qty_diff = inv_qty - valuation_total_qty
        return diff, qty_diff

    def _l10n_ro_get_or_create_price_difference_product(self):
        price_diff_product = (
            self.company_id.l10n_ro_property_stock_price_difference_product_id
        )
        if not price_diff_product:
            serv_acc = self.env["account.account"].search(
                [
                    ("account_type", "=", "expense"),
                    ("company_id", "=", self.company_id.id),
                ],
                limit=1,
            )
    
            price_diff_product = self.env["product.product"].create(
                {
                    "name": "Price Difference Between Reception and Bill",
                    "categ_id": self.env.ref("product.product_category_all").id,
                    "type": "service",
                    "landed_cost_ok": True,
                    "property_account_expense_id": serv_acc if serv_acc else False,
                }
            )
    
            self.sudo().company_id.l10n_ro_property_stock_price_difference_product_id = (
                price_diff_product
            )
    
        return price_diff_product
